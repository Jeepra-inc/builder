"use client";

import React, { useCallback, useEffect, useState, useRef, createContext } from "react";
import "./HeaderLayoutBuilder.css";
import { Button } from "@/components/ui/button";
import { getAllHeaderItems } from "../data/headerItems";
import { presetLayouts } from "../data/headerPresets";
import { DndProvider, useDrag, useDrop } from "react-dnd";
import { HTML5Backend } from "react-dnd-html5-backend";

// Define the layout context type
interface LayoutContextType {
  layout: HeaderLayout;
  setLayout: React.Dispatch<React.SetStateAction<HeaderLayout>>;
}

// Create the layout context
const LayoutContext = createContext<LayoutContextType>({
  layout: presetLayouts.preset1,
  setLayout: () => {},
});

interface HeaderLayoutBuilderProps {
  onShowPresets?: () => void;
  onShowHeaderMain?: () => void;
  isOpen: boolean;
  onClose: () => void;
  contentRef: React.RefObject<HTMLIFrameElement | null>;
  currentPreset?: string;
  onSettingSelect?: (settingId: string) => void;
  onSwitchToDesign?: () => void;
  onOpenLayoutPanel: () => void;
  onSelectPreset?: (presetId: string) => void;
  headerSettings?: any; // Add headerSettings prop
}

// Define item types for drag and drop
const ItemTypes = {
  HEADER_ITEM: "headerItem",
};

// Map header items to their corresponding settings panels
const itemToSettingsMap = {
  // HTML blocks
  html_block_1: { targetTab: "Header", targetSubmenu: "HTML" },
  html_block_2: { targetTab: "Header", targetSubmenu: "HTML" },
  html_block_3: { targetTab: "Header", targetSubmenu: "HTML" },
  html_block_4: { targetTab: "Header", targetSubmenu: "HTML" },
  html_block_5: { targetTab: "Header", targetSubmenu: "HTML" },

  // Logo
  logo: { targetTab: "Header", targetSubmenu: "Header Main Setting" },

  // Navigation
  mainMenu: { targetTab: "Header", targetSubmenu: "Header Navigation Setting" },
  topBarMenu: {
    targetTab: "Header",
    targetSubmenu: "Header Navigation Setting",
  },

  // Search
  search: { targetTab: "Header", targetSubmenu: "Header Search Setting" },

  // Buttons
  button_1: { targetTab: "Header", targetSubmenu: "Buttons" },
  button_2: { targetTab: "Header", targetSubmenu: "Buttons" },
  buttons: { targetTab: "Header", targetSubmenu: "Buttons" },

  // Social
  followIcons: { targetTab: "Header", targetSubmenu: "Social" },

  // Top bar
  topBar: { targetTab: "Header", targetSubmenu: "Top Bar Setting" },

  // Header sections
  headerMain: { targetTab: "Header", targetSubmenu: "Header Main Setting" },
  headerBottom: { targetTab: "Header", targetSubmenu: "Header Bottom Setting" },

  // Account
  account: { targetTab: "Header", targetSubmenu: "Buttons" },

  // Cart
  cart: { targetTab: "Header", targetSubmenu: "Buttons" },
};

// Define interface for DraggableItem props
interface DraggableItemProps {
  item: {
    id: string;
    type?: string;
    label?: string;
    icon?: string;
    [key: string]: any; // For any additional properties
  };
  index: number;
  moveItem: (dragIndex: number, hoverIndex: number, sourceContainer: string, targetContainer: string) => void;
  containerId: string;
  onItemClick?: (itemId: string) => void;
}

// Draggable item component
const DraggableItem = ({ item, index, moveItem, containerId, onItemClick }: DraggableItemProps) => {
  // Check if the item is a logo - we want to make it non-draggable
  const isLogo = item.id === "logo";
  // Check if this item is in the available items container
  const isInAvailableItems = containerId === "available";

  // Log when we encounter a logo item and its container
  useEffect(() => {
    if (isLogo) {
      console.log(`Logo found in container: ${containerId}`);
    }
  }, [isLogo, containerId]);

  // Only allow dragging if it's not a logo
  const [{ isDragging }, drag] = useDrag({
    type: ItemTypes.HEADER_ITEM,
    item: () => {
      console.log(`Starting drag for item: ${item.id} from ${containerId}[${index}]`);
      return {
        id: item.id,
        item,
        index,
        containerId,
      };
    },
    collect: (monitor) => ({
      isDragging: !!monitor.isDragging(),
    }),
    // Make logo non-draggable
    canDrag: !isLogo,
    end: (item, monitor) => {
      // Log when drag ends
      const didDrop = monitor.didDrop();
      console.log(`Drag ended for ${item?.id}, dropped: ${didDrop}`);
      
      // If the item was not dropped on a valid target and it's from the layout (not available items)
      // we might want to handle this case differently
      if (!didDrop && containerId !== 'available') {
        console.log(`Item ${item?.id} was not dropped on a valid target and will return to its original position`);
      }
    },
  });

  const [, drop] = useDrop({
    accept: ItemTypes.HEADER_ITEM,
    hover(item: { id: string; index: number; containerId: string; item: HeaderItem }, monitor) {
      if (!drag) {
        console.log('Skipping hover - drag ref not available');
        return;
      }
      
      // Skip hover handling for logo items
      if (isLogo) {
        console.log('Skipping hover - target is a logo item');
        return;
      }

      const dragIndex = item.index;
      const hoverIndex = index;
      const dragContainerId = item.containerId;
      const hoverContainerId = containerId;

      // Don't replace items with themselves
      if (dragIndex === hoverIndex && dragContainerId === hoverContainerId) {
        return;
      }
      
      // Get the bounding rectangle of the hover target
      const hoverBoundingRect = dragRef.current?.getBoundingClientRect();
      if (!hoverBoundingRect) {
        return;
      }
      
      // Get the dimensions of the hover target
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
      
      // Get mouse position
      const clientOffset = monitor.getClientOffset();
      if (!clientOffset) {
        return;
      }
      
      // Get pixels to the top and left
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;
      const hoverClientX = clientOffset.x - hoverBoundingRect.left;
      
      // Calculate distance from the center as a percentage (0-100)
      const distanceFromCenterY = Math.abs((hoverClientY / hoverMiddleY) - 1) * 100;
      const distanceFromCenterX = Math.abs((hoverClientX / hoverMiddleX) - 1) * 100;
      
      // If the cursor is too far from the center of the item, don't trigger the move
      // This helps prevent accidental moves when dragging past items
      if (distanceFromCenterY > 80 || distanceFromCenterX > 80) {
        console.log('Cursor too far from center of item, skipping hover');
        return;
      }
      
      // Only perform the move when the mouse has crossed half of the item's height
      // When dragging downwards, only move when the cursor is below 50%
      // When dragging upwards, only move when the cursor is above 50%
      
      // Dragging downwards
      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
        return;
      }
      
      // Dragging upwards
      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
        return;
      }
      
      console.log(`Hover: Moving ${item.id} from ${dragContainerId}[${dragIndex}] to ${hoverContainerId}[${hoverIndex}]`);

      // Time to actually perform the action
      moveItem(
        dragIndex,
        hoverIndex,
        dragContainerId,
        hoverContainerId
      );

      // Note: we're mutating the monitor item here!
      // Generally it's better to avoid mutations,
      // but it's good here for the sake of performance
      // to avoid expensive index searches.
      item.index = hoverIndex;
      item.containerId = hoverContainerId;
    },
  });

  // Create a ref for the drag element
  const dragRef = useRef<HTMLDivElement | null>(null);
  
  // Connect both drag and drop refs
  const ref = useCallback((node: HTMLDivElement | null) => {
    dragRef.current = node;
    drag(node);
    drop(node);
  }, [drag, drop]);

  return (
    <div
      ref={ref}
      className={`px-4 py-2 rounded text-xs ${
        isLogo ? "bg-yellow-100 border border-yellow-500" : "bg-blue-100"
      } 
        ${
          isLogo ? "cursor-default w-auto inline-block" : "cursor-move"
        } select-none whitespace-nowrap 
        ${isDragging ? "opacity-50 ring-2 ring-blue-500 shadow-lg scale-105" : ""} 
        transition-all duration-200 ease-in-out hover:bg-opacity-80 hover:shadow-md
        flex items-center gap-1 shrink-0
        h-[32px] my-1`}
      onClick={() => {
        // Only allow click to open settings if not in available items
        if (!isInAvailableItems && onItemClick) {
          onItemClick(item.id);
        }
      }}
      style={{
        opacity: isDragging ? 0.5 : 1,
        width: isLogo ? "fit-content" : "auto",
      }}
    >
      {/* Add lock icon for logo items */}
      {isLogo && (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="12"
          height="12"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
          <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
        </svg>
      )}
      <div className="flex items-center justify-between w-full">
        <div>
          {item.builderLabel || item.label}
          {isLogo && <span className="text-[10px] italic ml-1">(locked)</span>}
        </div>
        {!isInAvailableItems && !isLogo && (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-4 w-4 ml-2 text-gray-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
            />
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
            />
          </svg>
        )}
      </div>
    </div>
  );
};

// Define interface for DroppableZone props
interface DroppableZoneProps {
  id: string;
  items: string[];
  moveItem: (dragIndex: number, hoverIndex: number, sourceContainer: string, targetContainer: string) => void;
  onItemClick?: (itemId: string) => void;
  className?: string;
}

// Droppable zone component
const DroppableZone = ({
  id,
  items,
  moveItem,
  onItemClick,
  className = "",
}: DroppableZoneProps) => {
  // Get access to the layout state from the parent component
  // This is needed for the drop handler
  const { layout, setLayout } = React.useContext(LayoutContext);
  // Check if this container has a logo item
  const hasLogo = items.includes("logo");
  
  // Check if this is a top row container
  const isTopRow = id.startsWith("top_");

  // Log containers with logo items
  useEffect(() => {
    if (hasLogo) {
      console.log(`Container ${id} contains logo - will be non-droppable`);
    }
  }, [hasLogo, id, items]);

  // Create the drop ref conditionally based on whether this container has a logo
  const [{ isOver, canDrop }, drop] = useDrop({
    accept: ItemTypes.HEADER_ITEM,
    canDrop: (item) => {
      // Log the drop attempt
      console.log(`Checking if can drop item ${item.id} into container ${id}`);
      
      // Always block drops in logo containers
      if (hasLogo) {
        console.log(`Preventing drop in ${id} because it contains a logo`);
        return false;
      }
      
      // Prevent dropping a logo into any area that already has items
      if (item.id === "logo" && items.length > 0) {
        console.log(
          `Preventing logo drop in ${id} because it already has items`
        );
        return false;
      }
      
      // Allow drops from available items
      if (item.containerId === 'available') {
        console.log(`Allowing drop from available items: ${item.id}`);
        return true;
      }
      
      // Allow drops from other containers
      return true;
    },
    drop: (droppedItem: { id: string; containerId: string; index: number }) => {
      // Triple-check to prevent drops in logo containers
      if (hasLogo) {
        console.log(`Blocked drop in ${id} because it contains a logo`);
        return { name: id };
      }

      // Prevent drops of logo items
      if (droppedItem.id === "logo") {
        // Special case: Only allow logo drops in empty containers
        if (items.length > 0) {
          console.log(`Blocked logo drop in ${id} because container has items`);
          return { name: id };
        }
      }

      // If the item is dropped but not from a hover event (i.e., a new item from available)
      if (droppedItem.containerId !== id) {
        console.log(`Container drop: Moving item ${droppedItem.id} from ${droppedItem.containerId}[${droppedItem.index}] to ${id}[${items.length}]`);
        
        // Check if this is a drop from the available items container
        if (droppedItem.containerId === 'available') {
          console.log('Handling drop from available items:', droppedItem);
          
          // For available items, we need to use the item.id directly
          // This is the most reliable way to get the correct item ID
          if (droppedItem.id) {
            console.log(`Using item.id for available drop: ${droppedItem.id}`);
            
            // Create a new version of the layout with the item added to this container
            setLayout(prevLayout => {
              const newLayout = { ...prevLayout };
              
              // Check if the item already exists in any container
              let itemExistsInLayout = false;
              let existingContainerId = "";
              let existingIndex = -1;
              
              Object.keys(prevLayout).forEach(containerId => {
                const containerItems = prevLayout[containerId as keyof HeaderLayout];
                const itemIndex = containerItems.indexOf(droppedItem.id);
                
                if (itemIndex !== -1) {
                  itemExistsInLayout = true;
                  existingContainerId = containerId;
                  existingIndex = itemIndex;
                  console.log(`Found item ${droppedItem.id} in container ${containerId} at index ${itemIndex}`);
                }
              });
              
              // If the item exists somewhere, move it from there
              if (itemExistsInLayout) {
                console.log(`Item ${droppedItem.id} already exists in layout, moving from ${existingContainerId} to ${id}`);
                
                // Remove from existing container
                const existingContainer = [...prevLayout[existingContainerId as keyof HeaderLayout]];
                existingContainer.splice(existingIndex, 1);
                newLayout[existingContainerId as keyof HeaderLayout] = existingContainer;
                
                // Add to target container
                const targetContainer = [...(prevLayout[id as keyof HeaderLayout] || [])];
                targetContainer.push(droppedItem.id);
                newLayout[id as keyof HeaderLayout] = targetContainer;
              } else {
                // Item doesn't exist in layout, add it to the target container
                console.log(`Adding new item ${droppedItem.id} to container ${id}`);
                const targetContainer = [...(prevLayout[id as keyof HeaderLayout] || [])];
                targetContainer.push(droppedItem.id);
                newLayout[id as keyof HeaderLayout] = targetContainer;
              }
              
              return newLayout;
            });
            
            // Return early since we've handled this case specially
            return { name: id };
          }
        }
        
        // For non-available containers or if we need to move an item that exists in the layout
        if (droppedItem.containerId === 'available') {
          // When dropping from available, we need to pass the item ID as the sourceIndex
          // This is a special case handled in the moveItem function
          console.log(`Using special handling for available item: ${droppedItem.id}`);
          moveItem(
            droppedItem.id as unknown as number, // Pass the item ID as the sourceIndex
            items.length, // Add to the end of this container
            droppedItem.containerId,
            id
          );
        } else {
          // For regular containers, use the standard approach
          moveItem(
            droppedItem.index,
            items.length, // Add to the end of this container
            droppedItem.containerId,
            id
          );
        }
      }
      return { name: id };
    },
    collect: (monitor) => ({
      isOver: !!monitor.isOver(),
      canDrop: !!monitor.canDrop(),
    }),
  });

  // Calculate specific styles for different containers
  // Initialize container style with properties for filling available space first, then expanding
  const containerStyle: React.CSSProperties = {
    minWidth: hasLogo ? "fit-content" : "0",
    width: hasLogo ? "auto" : "100%",
    flex: hasLogo ? "0 0 auto" : "1 1 auto",
    maxWidth: "none",
  };

  // Special styling for logo containers
  if (hasLogo) {
    containerStyle.width = "fit-content";
    containerStyle.minWidth = "120px"; // Minimum width for logo container
    containerStyle.justifySelf = "start"; // Align to start of grid cell
    containerStyle.maxWidth = "25%"; // Prevent logo from taking too much space
  } else {
    // For non-logo containers, ensure they expand to fill space
    containerStyle.width = "100%";
    containerStyle.minWidth = "0"; // Allow shrinking to accommodate other elements
  }

  // Center alignment for center columns
  if (id.includes("center")) {
    containerStyle.justifySelf = "stretch"; // Stretch to fill the cell
    containerStyle.textAlign = "center"; // Center the content
  }

  // Right alignment for right columns
  if (id.includes("right")) {
    containerStyle.justifySelf = "end";
  }

  // Special styling for available items
  if (id === "available") {
    containerStyle.width = "100%";
    containerStyle.background = "rgba(0, 0, 0, 0.2)";
    containerStyle.border = "1px dashed rgba(255, 255, 255, 0.2)";
    containerStyle.minHeight = "60px";
    containerStyle.justifySelf = "stretch";
    // Allow wrapping for the available items section
    containerStyle.flexWrap = "wrap";
  }

  // Determine flexbox justification based on position
  const justifyClass = id.includes("center")
    ? "justify-center"
    : id.includes("right")
    ? "justify-end"
    : "justify-start";

  // Create a ref for the container element
  const containerRef = useRef<HTMLDivElement>(null);

  // Use a callback ref to merge the container ref and drop ref
  const mergedRef = useCallback(
    (node: HTMLDivElement | null) => {
      // Update the container ref
      containerRef.current = node;
      
      // Only apply the drop ref if this container doesn't have a logo
      if (!hasLogo) {
        drop(node);
      }
    },
    [drop, hasLogo]
  );

  return (
    <div
      ref={mergedRef}
      className={`drop-target px-2 relative
                 ${
                   isOver && canDrop
                     ? "bg-zinc-800"
                     : hasLogo
                     ? "bg-zinc-700"
                     : "bg-zinc-900"
                 } 
                 border ${
                   isOver && canDrop
                     ? "border-blue-500 border-2"
                     : hasLogo
                     ? "border-yellow-500"
                     : "border-dashed border-gray-300"
                 } 
                 rounded shadow-sm min-h-[50px] flex gap-2 items-center ${justifyClass}
                 transition-all duration-200 ease-in-out
                 ${hasLogo ? "cursor-not-allowed" : ""}
                 whitespace-nowrap
                 ${className}`}
      title={
        hasLogo
          ? "This area contains a logo and cannot be modified by the preset layout"
          : ""
      }
    >
      {/* Add drop indicator when hovering */}
      {isOver && canDrop && !hasLogo && (
        <div 
          className="absolute inset-0 flex items-center justify-center z-10 pointer-events-none"
          style={{ backgroundColor: 'rgba(59, 130, 246, 0.1)' }}
        >
          <div className="text-blue-400 text-xs font-medium bg-blue-900 px-2 py-1 rounded">
            Drop here
          </div>
        </div>
      )}
      
      {/* Add info icon for logo containers */}
      {hasLogo && (
        <>
          {/* Add protective overlay to completely block interaction */}
          <div
            className="absolute inset-0 bg-transparent z-10"
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log("Interaction with logo container blocked");
            }}
          />

          <div className="absolute top-0 right-0 -mt-2 -mr-2 bg-yellow-500 text-white rounded-full w-5 h-5 flex items-center justify-center z-20">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="14"
              height="14"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="16" x2="12" y2="12"></line>
              <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
          </div>
        </>
      )}
      {items.map((itemId, index) => {
        const item = getAllHeaderItems().find((i) => i.id === itemId);
        if (!item) return null;

        return (
          <DraggableItem
            key={itemId}
            item={item}
            index={index}
            containerId={id}
            moveItem={moveItem}
            onItemClick={onItemClick}
          />
        );
      })}
    </div>
  );
};

// Define the type for the layout structure
interface HeaderLayout {
  [key: string]: string[];
  top_left: string[];
  top_center: string[];
  top_right: string[];
  middle_left: string[];
  middle_center: string[];
  middle_right: string[];
  bottom_left: string[];
  bottom_center: string[];
  bottom_right: string[];
  available: string[];
}

export function HeaderLayoutBuilder({
  isOpen,
  onClose,
  contentRef,
  currentPreset = "preset1",
  onOpenLayoutPanel,
  onSelectPreset,
  headerSettings, // Add headerSettings to destructuring
}: HeaderLayoutBuilderProps) {
  // Create a static variable to store layouts across component instances
  // This needs to be outside the component to truly persist
  const staticLayoutStore = (() => {
    // Use a module-level variable that persists across renders
    if (!(window as any).__headerLayoutStore) {
      console.log('HeaderLayoutBuilder: Creating global layout store');
      (window as any).__headerLayoutStore = {
        layouts: {} as Record<string, HeaderLayout>,
        initialized: false
      };
    }
    return (window as any).__headerLayoutStore;
  })();
  
  // Request the current layout from the parent window
  useEffect(() => {
    if (isOpen) {
      console.log('%c HeaderLayoutBuilder: Requesting current layout from parent', 'background: #222; color: #bada55');
      
      // Clear any previous timeouts
      const timeoutIds: number[] = [];
      
      // Request the current layout from the parent window
      // Try multiple times with increasing delays to ensure we get a response
      [50, 200, 500, 1000].forEach(delay => {
        const timeoutId = window.setTimeout(() => {
          console.log(`Requesting layout with delay: ${delay}ms`);
          window.parent.postMessage({
            type: "REQUEST_CURRENT_HEADER_LAYOUT",
            presetId: currentPreset
          }, '*');
        }, delay);
        timeoutIds.push(timeoutId);
      });
      
      return () => {
        // Clean up all timeouts when component unmounts
        timeoutIds.forEach(id => window.clearTimeout(id));
      };
    }
  }, [isOpen, currentPreset]);
  
  // Initialize the layout state using headerSettings prop if available
  const [layout, setLayout] = useState<HeaderLayout>(() => {
    // First check if we have headerSettings with layout data
    if (headerSettings?.layout?.containers) {
      console.log('%c HeaderLayoutBuilder: Using layout from headerSettings prop', 'background: #222; color: #bada55', headerSettings.layout.containers);
      // Store it for future use
      staticLayoutStore.layouts[currentPreset] = headerSettings.layout.containers;
      return headerSettings.layout.containers;
    }
    
    // If we have a stored layout for this preset, use it
    if (staticLayoutStore.layouts[currentPreset]) {
      console.log('%c HeaderLayoutBuilder: Using stored layout for preset:', 'background: #222; color: #bada55', currentPreset);
      return staticLayoutStore.layouts[currentPreset];
    }
    
    // Create an empty layout that matches the structure but has no items
    // This prevents showing default layouts momentarily
    console.log('%c HeaderLayoutBuilder: Using empty layout initially, waiting for parent data', 'background: #222; color: #bada55');
    const emptyLayout = {
      left: [],
      center: [],
      right: [],
      mobileLeft: [],
      mobileRight: []
    };
    
    return emptyLayout;
  });

  // Update the stored layout whenever layout changes
  useEffect(() => {
    console.log('HeaderLayoutBuilder: Storing layout for preset:', currentPreset);
    staticLayoutStore.layouts[currentPreset] = layout;
  }, [layout, currentPreset]);
  
  // Update layout when headerSettings changes
  useEffect(() => {
    if (headerSettings?.layout?.containers && isOpen) {
      console.log('%c HeaderLayoutBuilder: headerSettings changed, updating layout', 'background: purple; color: white', headerSettings.layout.containers);
      setLayout(headerSettings.layout.containers);
      staticLayoutStore.layouts[currentPreset] = headerSettings.layout.containers;
    }
  }, [headerSettings, isOpen, currentPreset]);
  
  // When the component opens, check if we need to initialize with preset layout
  // We've completely removed this initialization logic since we now rely on the parent to provide the layout
  // This prevents any chance of resetting to default layouts
  useEffect(() => {
    if (isOpen) {
      console.log('%c HeaderLayoutBuilder: Component opened, waiting for layout from parent', 'background: #222; color: #bada55');
      
      // Force apply the layout after a delay as a final safety measure
      const finalCheckTimer = setTimeout(() => {
        const hasItems = Object.values(layout).some(container => container.length > 0);
        console.log('%c HeaderLayoutBuilder: Final layout check', 'background: purple; color: white', {
          hasItems,
          layout,
          headerSettings: headerSettings?.layout?.containers
        });
        
        if (!hasItems && headerSettings?.layout?.containers) {
          console.log('%c HeaderLayoutBuilder: Final safety - applying headerSettings layout', 'background: purple; color: white');
          setLayout(headerSettings.layout.containers);
          setTimeout(() => applyLayoutToIframe(), 100);
        } else if (hasItems) {
          console.log('%c HeaderLayoutBuilder: Final safety - layout has items, applying', 'background: purple; color: white');
          applyLayoutToIframe();
        }
      }, 2000);
      
      return () => clearTimeout(finalCheckTimer);
    }
  }, [isOpen, layout, headerSettings, applyLayoutToIframe]); // Add dependencies
  
  // Handle preset changes after initial mount
  const handlePresetChange = useCallback((newPreset: string) => {
    if (newPreset && presetLayouts[newPreset as keyof typeof presetLayouts]) {
      // Check if we already have a stored layout for this preset
      if (staticLayoutStore.layouts[newPreset]) {
        console.log('HeaderLayoutBuilder: Using stored layout for preset change:', newPreset);
        setLayout(staticLayoutStore.layouts[newPreset]);
      } else {
        // If not, use the default preset layout
        console.log('HeaderLayoutBuilder: Using default layout for preset change:', newPreset);
        setLayout(presetLayouts[newPreset as keyof typeof presetLayouts]);
        // Store it for future use
        staticLayoutStore.layouts[newPreset] = presetLayouts[newPreset as keyof typeof presetLayouts];
      }
    }
  }, [staticLayoutStore]);
  
  // Function to apply the current layout to the iframe
  const applyLayoutToIframe = useCallback(() => {
    if (currentPreset) {
      // Check if we have a valid layout with items
      const hasItems = Object.values(layout).some(container => container.length > 0);
      
      console.log('%c HeaderLayoutBuilder: Applying layout to iframe:', 'background: #222; color: #bada55', {
        currentPreset,
        layout,
        hasItems
      });
      
      // Only apply if we have a valid layout with items
      if (hasItems) {
        // Send message to iframe to update the header layout using the current layout state
        contentRef.current?.contentWindow?.postMessage(
          {
            type: "UPDATE_HEADER_LAYOUT",
            presetId: currentPreset,
            ...layout, // Use the current layout state instead of preset layout
          },
          "*"
        );
        
        // Also save the current layout to the parent component's headerSettings
        window.dispatchEvent(
          new CustomEvent("updateHeaderLayout", {
            detail: {
              layout: layout, // Use the current layout state
              presetId: currentPreset
            }
          })
        );
        
        // Update our static store
        staticLayoutStore.layouts[currentPreset] = layout;
        console.log('Updated staticLayoutStore after apply:', staticLayoutStore);
      } else {
        console.log('%c HeaderLayoutBuilder: Not applying empty layout', 'background: #222; color: red');
      }
    }
  }, [currentPreset, contentRef, layout]); // Add layout to dependencies
  
  // When the component is opened, ensure we have the correct layout and apply it
  useEffect(() => {
    if (isOpen) {
      console.log('%c HeaderLayoutBuilder: Component opened', 'background: #222; color: #bada55');
      console.log('Current headerSettings:', headerSettings);
      
      // If we have headerSettings with layout data, use it directly
      if (headerSettings?.layout?.containers) {
        console.log('%c HeaderLayoutBuilder: Using layout from headerSettings prop', 'background: #222; color: #bada55', headerSettings.layout.containers);
        setLayout(headerSettings.layout.containers);
        staticLayoutStore.layouts[currentPreset] = headerSettings.layout.containers;
      } else {
        // Otherwise request from parent as a fallback
        console.log('%c HeaderLayoutBuilder: No headerSettings prop, requesting from parent', 'background: #222; color: #bada55');
        window.parent.postMessage({
          type: "REQUEST_CURRENT_HEADER_LAYOUT",
          presetId: currentPreset
        }, '*');
      }
      
      // Apply the current layout to the iframe after a small delay to ensure component is mounted
      const timer = setTimeout(() => {
        // Check if we have a valid layout with items before applying
        const hasItems = Object.values(layout).some(container => container.length > 0);
        
        if (hasItems) {
          console.log('%c HeaderLayoutBuilder: Applying layout to iframe after open', 'background: #222; color: #bada55');
          applyLayoutToIframe();
        } else if (headerSettings?.layout?.containers) {
          // Try using headerSettings directly if layout is still empty
          console.log('%c HeaderLayoutBuilder: Applying headerSettings layout directly', 'background: #222; color: #bada55');
          setLayout(headerSettings.layout.containers);
          setTimeout(() => applyLayoutToIframe(), 100);
        } else {
          console.log('%c HeaderLayoutBuilder: Not applying empty layout after open', 'background: #222; color: red');
          // Try requesting the layout again as a last resort
          window.parent.postMessage({
            type: "REQUEST_CURRENT_HEADER_LAYOUT",
            presetId: currentPreset
          }, '*');
        }
      }, 1000); // Increased timeout to ensure we get the layout from parent first
      
      return () => clearTimeout(timer);
    }
  }, [isOpen, applyLayoutToIframe, layout, currentPreset, headerSettings]);
  
  // Listen for layout updates from iframe or parent
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (!event.data || typeof event.data !== 'object') return;
      
      // Only log messages we're interested in to reduce console noise
      if (['HEADER_LAYOUT_UPDATED', 'CURRENT_HEADER_LAYOUT', 'PARENT_HEADER_LAYOUT'].includes(event.data.type)) {
        console.log('HeaderLayoutBuilder received message:', event.data);
      }
      
      // Handle receiving the current layout from the parent
      if (event.data.type === "PARENT_HEADER_LAYOUT") {
        console.log('%c HeaderLayoutBuilder: Received layout from parent:', 'background: #222; color: #bada55', event.data);
        if (event.data.layout && Object.keys(event.data.layout).length > 0) {
          // Update our local layout state with the parent's current layout
          console.log('%c HeaderLayoutBuilder: Setting layout from parent data', 'background: #222; color: #bada55');
          
          // If a preset ID was provided, use it
          const targetPreset = event.data.presetId || currentPreset;
          console.log('Using preset:', targetPreset, 'Current preset:', currentPreset);
          
          // Update the layout state
          setLayout(event.data.layout);
          
          // Store it for future use
          staticLayoutStore.layouts[targetPreset] = event.data.layout;
          console.log('Updated staticLayoutStore:', staticLayoutStore);
          
          // Apply the layout immediately to ensure it's visible
          setTimeout(() => {
            console.log('%c HeaderLayoutBuilder: Applying layout from message immediately', 'background: #222; color: #bada55');
            // Send to iframe
            contentRef.current?.contentWindow?.postMessage(
              {
                type: "UPDATE_HEADER_LAYOUT",
                presetId: targetPreset,
                ...event.data.layout,
              },
              "*"
            );
          }, 100);
        } else {
          console.log('%c HeaderLayoutBuilder: Received empty layout from parent', 'background: #222; color: red');
        }
      }
      
      // Handle preset changes from the iframe
      if (event.data.type === "HEADER_LAYOUT_UPDATED") {
        const { presetId } = event.data;
        if (presetId && presetLayouts[presetId as keyof typeof presetLayouts] && presetId !== currentPreset) {
          // Use the handlePresetChange function to update the layout
          handlePresetChange(presetId);

          // Notify parent that we've updated the layout (if onSelectPreset callback is provided)
          if (onSelectPreset) {
            onSelectPreset(presetId);
          }
        }
      }
    };

    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, [currentPreset, onSelectPreset, handlePresetChange]);

  const handleItemClick = useCallback((itemId: string) => {
    // Find the appropriate settings panel for this item
    const settingsInfo = itemToSettingsMap[itemId as keyof typeof itemToSettingsMap];

    if (settingsInfo) {
      // Dispatch event to switch to the appropriate settings panel
      window.dispatchEvent(
        new CustomEvent("switchTab", {
          detail: {
            targetTab: settingsInfo.targetTab,
            targetSubmenu: settingsInfo.targetSubmenu,
          },
        })
      );
    } else {
      // Default to HTML settings for HTML blocks (fallback)
      if (itemId.startsWith("html_block_")) {
        window.dispatchEvent(
          new CustomEvent("switchTab", {
            detail: {
              targetTab: "Header",
              targetSubmenu: "HTML",
              settingId: itemId,
            },
          })
        );
      }
    }
  }, []);

  const moveItem = useCallback(
    (
      sourceIndex: number,
      targetIndex: number,
      sourceContainerId: string,
      targetContainerId: string
    ) => {
      console.log(`moveItem called: ${sourceIndex} -> ${targetIndex}, ${sourceContainerId} -> ${targetContainerId}`);
      
      setLayout((prevLayout: HeaderLayout) => {
        // Create a new layout object to avoid mutation
        const newLayout: HeaderLayout = { ...prevLayout };
        
        // Special case: If source container is 'available', we need to handle differently
        if (sourceContainerId === 'available') {
          console.log('Moving from available items container');
          
          // For available items, sourceIndex is actually the item ID
          const itemId = sourceIndex.toString();
          console.log(`Item ID from available: ${itemId}`);
          
          // Check if the item already exists in any container
          let existingContainerId = '';
          let existingItemIndex = -1;
          
          Object.keys(prevLayout).forEach(containerId => {
            const containerItems = prevLayout[containerId as keyof HeaderLayout];
            const itemIndex = containerItems.indexOf(itemId);
            
            if (itemIndex !== -1) {
              existingContainerId = containerId;
              existingItemIndex = itemIndex;
              console.log(`Found item ${itemId} in container ${containerId} at index ${itemIndex}`);
            }
          });
          
          // If the item exists somewhere, move it from there
          if (existingContainerId) {
            const existingContainer = [...prevLayout[existingContainerId as keyof HeaderLayout]];
            existingContainer.splice(existingItemIndex, 1);
            newLayout[existingContainerId as keyof HeaderLayout] = existingContainer;
            
            // Now add it to the target container
            const targetContainer = [...(prevLayout[targetContainerId as keyof HeaderLayout] || [])];
            targetContainer.splice(targetIndex, 0, itemId);
            newLayout[targetContainerId as keyof HeaderLayout] = targetContainer;
            
            return newLayout;
          }
          
          // If item doesn't exist in layout, add it to the target container
          const targetContainer = [...(prevLayout[targetContainerId as keyof HeaderLayout] || [])];
          targetContainer.splice(targetIndex, 0, itemId);
          newLayout[targetContainerId as keyof HeaderLayout] = targetContainer;
          
          return newLayout;
        }
        
        // Regular case: Moving between containers in the layout
        // Check if target container already has a logo
        const targetContainer =
          prevLayout[targetContainerId as keyof HeaderLayout] || [];
        if (targetContainer.includes("logo")) {
          console.error(
            `Cannot move item to ${targetContainerId}: container already has a logo`
          );
          return prevLayout; // Return original layout without changes
        }

        // Check if we're trying to move a logo item
        const sourceContainer = prevLayout[sourceContainerId as keyof HeaderLayout] || [];
        const isMovingLogo = sourceContainer[sourceIndex] === "logo";

        // If moving logo to container with items, prevent the move
        if (isMovingLogo && targetContainer.length > 0 && sourceContainerId !== targetContainerId) {
          console.error(
            `Cannot move logo to ${targetContainerId}: container already has items`
          );
          return prevLayout; // Return original layout without changes
        }

        // If the item is dropped but not from a hover event (i.e., a new item from available)
        if (sourceContainerId === targetContainerId) {
          const container = [
            ...prevLayout[sourceContainerId as keyof HeaderLayout],
          ];
          // Remove the item from its original position
          const [movedItem] = container.splice(sourceIndex, 1);

          // Additional check: prevent moving a logo
          if (movedItem === "logo") {
            console.error("Cannot move logo item");
            return prevLayout; // Return original layout without changes
          }

          // Insert the item at the new position
          container.splice(targetIndex, 0, movedItem);
          // Update the container in the layout
          newLayout[sourceContainerId as keyof HeaderLayout] = container;
        }
        // If moving between different containers
        else {
          const sourceContainer = [
            ...prevLayout[sourceContainerId as keyof HeaderLayout],
          ];
          
          // Get the actual item ID directly from the source container at the source index
          const itemToMove = sourceContainer[sourceIndex];
          console.log(`Moving item between containers: ${itemToMove} from ${sourceContainerId}[${sourceIndex}] to ${targetContainerId}[${targetIndex}]`);

          // Prevent moving logo items between containers
          if (itemToMove === "logo") {
            console.error("Cannot move logo item between containers");
            return prevLayout; // Return original layout without changes
          }
          
          // Validate that we have a valid item to move
          if (!itemToMove) {
            console.error(`No item found at index ${sourceIndex} in container ${sourceContainerId}`);
            return prevLayout; // Return original layout without changes
          }

          // Remove the item from the source container
          sourceContainer.splice(sourceIndex, 1);
          newLayout[sourceContainerId as keyof HeaderLayout] = sourceContainer;

          // Add the item to the target container
          const targetContainer = [
            ...prevLayout[targetContainerId as keyof HeaderLayout],
          ];
          
          console.log(`Adding item to target container: ${itemToMove} to ${targetContainerId}[${targetIndex}]`);
          
          // Only proceed if we have a valid item to move
          if (itemToMove) {
            targetContainer.splice(targetIndex, 0, itemToMove);
            newLayout[targetContainerId as keyof HeaderLayout] = targetContainer;
          } else {
            console.error(`Failed to move item: Could not find item at index ${sourceIndex} in ${sourceContainerId}`);
          }
        }

        return newLayout;
      });
    },
    []
  );

  // This useEffect was removed as it was duplicating the functionality of applyLayoutToIframe
  // We now use the applyLayoutToIframe function directly, which is called when isOpen changes
  // and when the Apply Layout button is clicked

  if (!isOpen) return null;

  return (
    <DndProvider backend={HTML5Backend}>
      <LayoutContext.Provider value={{ layout, setLayout }}>
        <div
          className="bg-gray-100 z-50 absolute bottom-0 w-full bg-zinc-700"
          style={{ maxHeight: "60vh", overflowY: "auto", overflowX: "hidden" }}
        >
        <div className="flex align-center justify-between p-3 bg-white border-b border-t mb-2">
          <div>
            <h3>Header Builder</h3>
            <p className="text-xs text-gray-500 mt-1">
              Note: Logo positions are locked by the preset layout and cannot be
              modified.
            </p>
            <p className="text-xs text-blue-500 mt-1">
              Current preset: <strong>{currentPreset}</strong>
            </p>
          </div>
          <div className="flex align-center justify-between gap-2">
            <Button size="sm" onClick={onOpenLayoutPanel}>
              Preset
            </Button>
            <Button size="sm" onClick={() => {
              // Apply the current layout to the iframe
              console.log('Apply Layout button clicked, applying current layout');
              applyLayoutToIframe();
              // Provide feedback to the user
              alert(`Layout changes applied to header`);
            }}>
              Apply Layout
            </Button>
            <Button size="sm" onClick={onClose}>
              Close
            </Button>
          </div>
        </div>

        <div
          className="flex flex-col gap-2 p-3 w-full"
          style={{ overflowX: "auto", overflowY: "hidden" }}
        >
          {/* Top Row */}
          <div className="relative group">
            {/* Add gear icon with text for top row - only visible on hover */}
            <div 
              className="absolute top-0 right-0 -mt-3 -mr-3 bg-blue-500 text-white rounded-md pl-2 pr-3 py-1 flex items-center gap-1 z-30 cursor-pointer hover:bg-blue-600 shadow-md opacity-0 group-hover:opacity-100 transition-opacity duration-200"
              onClick={() => {
                // Dispatch event to open top bar settings
                window.dispatchEvent(
                  new CustomEvent("switchTab", {
                    detail: {
                      targetTab: "Header",
                      targetSubmenu: "Top Bar Setting",
                    },
                  })
                );
              }}
              title="Edit Top Bar Settings"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
              </svg>
              <span className="text-xs font-medium">Top Bar</span>
            </div>
            
            {/* Top row outline - only visible on hover */}
            <div className="absolute inset-0 border-2 border-blue-400 rounded-md pointer-events-none z-20 opacity-0 group-hover:opacity-100 transition-opacity duration-200" style={{ margin: "-2px" }}></div>
            
            <div
              className="grid gap-2 w-full flex-grow"
              style={{
                display: "grid",
                gridTemplateColumns: `${
                  layout.top_left.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                } ${
                  layout.top_center.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                } ${
                  layout.top_right.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                }`,
                width: "100%",
                maxWidth: "none",
              }}
            >
            <DroppableZone
              id="top_left"
              items={layout.top_left}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
            <DroppableZone
              id="top_center"
              items={layout.top_center}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
            <DroppableZone
              id="top_right"
              items={layout.top_right}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
          </div>
        </div>

          {/* Middle Row */}
          <div className="relative group">
            {/* Add gear icon with text for middle row - only visible on hover */}
            <div 
              className="absolute top-0 right-0 -mt-3 -mr-3 bg-blue-500 text-white rounded-md pl-2 pr-3 py-1 flex items-center gap-1 z-30 cursor-pointer hover:bg-blue-600 shadow-md opacity-0 group-hover:opacity-100 transition-opacity duration-200"
              onClick={() => {
                // Dispatch event to open header main settings
                window.dispatchEvent(
                  new CustomEvent("switchTab", {
                    detail: {
                      targetTab: "Header",
                      targetSubmenu: "Header Main Setting",
                    },
                  })
                );
              }}
              title="Edit Header Main Settings"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
              </svg>
              <span className="text-xs font-medium">Main Area</span>
            </div>
            
            {/* Middle row outline */}
            <div className="absolute inset-0 border-2 border-blue-400 rounded-md pointer-events-none z-20 opacity-0 group-hover:opacity-100 transition-opacity duration-200" style={{ margin: "-2px" }}></div>
            
            <div
              className="grid gap-2 w-full flex-grow"
              style={{
                display: "grid",
                gridTemplateColumns: `${
                  layout.middle_left.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                } ${
                  layout.middle_center.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                } ${
                  layout.middle_right.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                }`,
                width: "100%",
                maxWidth: "none",
              }}
            >
            <DroppableZone
              id="middle_left"
              items={layout.middle_left}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
            <DroppableZone
              id="middle_center"
              items={layout.middle_center}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
            <DroppableZone
              id="middle_right"
              items={layout.middle_right}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
          </div>
        </div>

          {/* Bottom Row */}
          <div className="relative group">
            {/* Add gear icon with text for bottom row - only visible on hover */}
            <div 
              className="absolute top-0 right-0 -mt-3 -mr-3 bg-blue-500 text-white rounded-md pl-2 pr-3 py-1 flex items-center gap-1 z-30 cursor-pointer hover:bg-blue-600 shadow-md opacity-0 group-hover:opacity-100 transition-opacity duration-200"
              onClick={() => {
                // Dispatch event to open header bottom settings
                window.dispatchEvent(
                  new CustomEvent("switchTab", {
                    detail: {
                      targetTab: "Header",
                      targetSubmenu: "Header Bottom Setting",
                    },
                  })
                );
              }}
              title="Edit Header Bottom Settings"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
              </svg>
              <span className="text-xs font-medium">Bottom Bar</span>
            </div>
            
            {/* Bottom row outline */}
            <div className="absolute inset-0 border-2 border-blue-400 rounded-md pointer-events-none z-20 opacity-0 group-hover:opacity-100 transition-opacity duration-200" style={{ margin: "-2px" }}></div>
            
            <div
              className="grid gap-2 w-full flex-grow"
              style={{
                display: "grid",
                gridTemplateColumns: `${
                  layout.bottom_left.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                } ${
                  layout.bottom_center.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                } ${
                  layout.bottom_right.includes("logo")
                    ? "auto"
                    : "minmax(min-content, 1fr)"
                }`,
                width: "100%",
                maxWidth: "none",
              }}
            >
            <DroppableZone
              id="bottom_left"
              items={layout.bottom_left}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
            <DroppableZone
              id="bottom_center"
              items={layout.bottom_center}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
            <DroppableZone
              id="bottom_right"
              items={layout.bottom_right}
              moveItem={moveItem}
              onItemClick={handleItemClick}
            />
          </div>
        </div>

          {/* Available Items */}
          <div className="flex mt-4 w-full">
            <div className="w-full p-2 bg-zinc-950 border-t border-zinc-700">
              <p className="text-xs text-white mb-2">Available Items:</p>
              <DroppableZone
                id="available"
                items={layout.available}
                moveItem={moveItem}
                onItemClick={handleItemClick}
                className="available-items"
              />
            </div>
          </div>
        </div>
      </div>
      </LayoutContext.Provider>
    </DndProvider>
  );
}
