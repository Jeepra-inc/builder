"use client";

import React, {
  useEffect,
  useState,
  useMemo,
  useRef,
  useCallback,
} from "react";
import clsx from "clsx";
import { getAllHeaderItems } from "../data/headerItems";
import { Facebook, Instagram, Linkedin, Phone, Twitter } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Pencil, Plus, X } from "lucide-react";
import {
  fetchColorSchemes,
  getColorSchemeStyles,
} from "@/app/builder/utils/colorSchemeUtils";

// Helper function to check if a custom color scheme is being used
const isCustomColorScheme = (schemeId?: string) => {
  return schemeId && schemeId !== "light" && schemeId !== "dark";
};

interface HeaderLayout {
  top_left: string[];
  top_center: string[];
  top_right: string[];
  middle_left: string[];
  middle_center: string[];
  middle_right: string[];
  bottom_left: string[];
  bottom_center: string[];
  bottom_right: string[];
  available?: string[];
}

class LayoutSettings {
  sticky: boolean = false; // initializing with a default value
  maxWidth: string = "";
  currentPreset?: string;
  containers?: HeaderLayout;
}

interface HeaderSettings {
  theme?: string;
  layout?: LayoutSettings;
  html_block_1?: string;
  html_block_2?: string;
  html_block_3?: string;
  html_block_4?: string;
  html_block_5?: string;
  topBarVisible?: boolean;
  topBarHeight?: number;
  showTopBarButton?: boolean;
  topBarColorScheme?: string;
  mainBarColorScheme?: string; // Added for main section
  bottomBarColorScheme?: string; // Added for bottom section
  topBarNavStyle?: "style1" | "style2" | "style3";
  topBarTextTransform?: "uppercase" | "capitalize" | "lowercase";
  logo?: { text?: string; showText?: boolean };
}

interface HeaderProps {
  settings?: HeaderSettings;
  isEditing?: boolean;
  isSelected?: boolean;
  onSelect?: () => void;
}

// Default HTML content for various header items
const HTMLContentMap: Record<string, string> = {
  logo: '<img src="/logo.svg" class="h-8" alt="Logo" />',
  account: `<div class="account-icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path>
      <circle cx="12" cy="7" r="4"></circle>
    </svg>
  </div>`,
  cart: `<div class="cart-icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="8" cy="21" r="1"></circle>
      <circle cx="19" cy="21" r="1"></circle>
      <path d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12"></path>
    </svg>
  </div>`,
  search: `<div class="search-box">
    <input type="text" placeholder="Search..." class="px-3 py-2 border rounded" />
    <button class="search-icon ml-2">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    </button>
  </div>`,
  mainMenu: `<nav class="main-menu">
    <ul class="flex gap-6">
      <li class="hover:text-primary cursor-pointer">Home</li>
      <li class="hover:text-primary cursor-pointer">Shop</li>
      <li class="hover:text-primary cursor-pointer">About</li>
      <li class="hover:text-primary cursor-pointer">Contact</li>
    </ul>
  </nav>`,
  topBarMenu: `<div class="top-bar-menu">
    <ul class="flex gap-3 text-sm">
      <li class="hover:underline cursor-pointer">Support</li>
      <li class="hover:underline cursor-pointer">Contact</li>
      <li class="hover:underline cursor-pointer">Store Locator</li>
    </ul>
  </div>`,
  followIcons: `<div class="social-icons flex gap-3">
    <a href="#" class="hover:text-primary">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>
      </svg>
    </a>
    <a href="#" class="hover:text-primary">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
        <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
        <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
      </svg>
    </a>
    <a href="#" class="hover:text-primary">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
      </svg>
    </a>
  </div>`,
  nav_icon: `<button class="flex items-center">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
    <span class="ml-2">Menu</span>
  </button>`,
  wishlist: `<div class="wishlist-icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78L12 21.23l8.84-8.84a5.5 5.5 0 0 0 0-7.78z"></path>
    </svg>
  </div>`,
  contact: `<div class="contact-info flex items-center">
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2">
      <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
    </svg>
    <span>+1 234 567 890</span>
  </div>`,
  social_icon: `<div class="social-icon-group flex gap-2">
    <a href="#" class="social-icon hover:text-primary">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>
      </svg>
    </a>
    <a href="#" class="social-icon hover:text-primary">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
      </svg>
    </a>
    <a href="#" class="social-icon hover:text-primary">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
        <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
        <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
      </svg>
    </a>
  </div>`,
  button_1: `<button class="px-4 py-2 bg-primary text-white rounded hover:bg-primary-dark">Button 1</button>`,
  button_2: `<button class="px-4 py-2 border border-primary text-primary rounded hover:bg-primary hover:text-white">Button 2</button>`,
  divider_1: `<div class="h-6 w-px bg-gray-300"></div>`,
  divider_2: `<div class="h-6 w-px bg-gray-300"></div>`,
  divider_3: `<div class="h-6 w-px bg-gray-300"></div>`,
  divider_4: `<div class="h-6 w-px bg-gray-300"></div>`,
};

const defaultHeaderSettings: HeaderSettings = {
  topBarVisible: true,
  topBarColorScheme: "light",
  mainBarColorScheme: "light", // Default for main section
  bottomBarColorScheme: "light", // Default for bottom section
  showTopBarButton: false,
};

function debounce<F extends (...args: any[]) => any>(
  func: F,
  wait: number
): (...args: Parameters<F>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null;
  return function (...args: Parameters<F>) {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
}

export default function Header({
  settings = {},
  isEditing,
  isSelected,
  onSelect,
}: HeaderProps) {
  const initHeaderSettings = useMemo(() => {
    return { ...defaultHeaderSettings, ...settings };
  }, [settings]);

  // State to store the header settings
  const [headerSettings, setHeaderSettings] =
    useState<HeaderSettings>(initHeaderSettings);

  // Add state for color scheme styles for all three sections
  const [topBarStyles, setTopBarStyles] = useState<{
    background: React.CSSProperties;
    text: React.CSSProperties;
  }>({
    background: {},
    text: {},
  });

  const [mainBarStyles, setMainBarStyles] = useState<{
    background: React.CSSProperties;
    text: React.CSSProperties;
  }>({
    background: {},
    text: {},
  });

  const [bottomBarStyles, setBottomBarStyles] = useState<{
    background: React.CSSProperties;
    text: React.CSSProperties;
  }>({
    background: {},
    text: {},
  });

  // Track the last received settings to prevent reprocessing identical settings
  const lastReceivedSettingsRef = useRef<string>("");

  // Add ref to track the last notified schemes to prevent notification loops
  const lastNotifiedSchemesRef = useRef({
    topBarColorScheme: headerSettings.topBarColorScheme || "light",
    mainBarColorScheme: headerSettings.mainBarColorScheme || "light",
    bottomBarColorScheme: headerSettings.bottomBarColorScheme || "light",
  });

  // Add notification throttling
  const notificationTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(
    null
  );

  // Function to safely notify parent about scheme changes
  const notifySchemeChanges = useCallback(
    (schemes: {
      topBarColorScheme?: string;
      mainBarColorScheme?: string;
      bottomBarColorScheme?: string;
    }) => {
      // Create scheme object with defaults
      const notifySchemes = {
        topBarColorScheme:
          schemes.topBarColorScheme ||
          headerSettings.topBarColorScheme ||
          "light",
        mainBarColorScheme:
          schemes.mainBarColorScheme ||
          headerSettings.mainBarColorScheme ||
          "light",
        bottomBarColorScheme:
          schemes.bottomBarColorScheme ||
          headerSettings.bottomBarColorScheme ||
          "light",
      };

      // Create string representation for comparison
      const schemesString = JSON.stringify(notifySchemes);

      // Only notify if schemes have changed from last notification
      if (JSON.stringify(lastNotifiedSchemesRef.current) !== schemesString) {
        // Clear any pending notification
        if (notificationTimeoutRef.current) {
          clearTimeout(notificationTimeoutRef.current);
        }

        // Use a ref to track that we're about to send this notification
        lastNotifiedSchemesRef.current = notifySchemes;

        // Debounce the notification
        notificationTimeoutRef.current = setTimeout(() => {
          console.log("Sending debounced scheme notification:", notifySchemes);
          window.parent.postMessage(
            {
              type: "HEADER_SCHEMES_UPDATED",
              schemes: notifySchemes,
            },
            "*"
          );
          notificationTimeoutRef.current = null;
        }, 200);
      }
    },
    [headerSettings]
  );

  const [layoutItems, setLayoutItems] = useState<HeaderLayout>({
    top_left: [],
    top_center: [],
    top_right: [],
    middle_left: [],
    middle_center: [],
    middle_right: [],
    bottom_left: [],
    bottom_center: [],
    bottom_right: [],
    available: [],
  });

  const [customHtml, setCustomHtml] = useState<Record<string, string>>({});

  // Add debouncing to prevent rapid state updates
  const settingsUpdateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Inside the Header component, after state declarations
  // Add debounced state setters to reduce re-rendering
  const debouncedSetLayoutItems = React.useMemo(
    () => debounce((newItems: HeaderLayout) => setLayoutItems(newItems), 100),
    []
  );

  // Update settings when props change but DON'T automatically send notifications
  useEffect(() => {
    if (JSON.stringify(headerSettings) !== JSON.stringify(settings)) {
      console.log("Settings changed from props, updating state only");
      setHeaderSettings((prev) => ({ ...prev, ...settings }));
    }
  }, [settings]);

  // Initialize layout items using containers from settings
  useEffect(() => {
    console.log("useEffect: initializing layout items from headerSettings");
    // Check if we have containers defined in the layout settings
    if (headerSettings.layout && headerSettings.layout.containers) {
      const containers = headerSettings.layout.containers;
      console.log("Containers found in settings:", containers);

      // Create new layout items based on containers or use default
      const newLayoutItems = {
        top_left: containers.top_left || [],
        top_center: containers.top_center || [],
        top_right: containers.top_right || [],
        middle_left: containers.middle_left || [],
        middle_center: containers.middle_center || [],
        middle_right: containers.middle_right || [],
        bottom_left: containers.bottom_left || [],
        bottom_center: containers.bottom_center || [],
        bottom_right: containers.bottom_right || [],
        available: containers.available || [],
      };

      // Update layout items
      console.log("Setting layout items to:", newLayoutItems);
      setLayoutItems(newLayoutItems);

      // If we have a currentPreset in the settings, notify the parent
      if (headerSettings.layout.currentPreset) {
        console.log(
          "Current preset found:",
          headerSettings.layout.currentPreset
        );
        window.parent.postMessage(
          {
            type: "HEADER_PRESET_LOADED",
            presetId: headerSettings.layout.currentPreset,
          },
          "*"
        );
      }
    } else {
      // Set default layout items if no containers in settings
      console.log("No layout containers found in settings, using defaults");

      // Default layout with common items
      const defaultLayout = {
        top_left: [] as string[],
        top_center: [] as string[],
        top_right: [] as string[],
        middle_left: ["mainMenu"] as string[],
        middle_center: ["logo"] as string[],
        middle_right: ["account", "cart"] as string[],
        bottom_left: ["search"] as string[],
        bottom_center: [] as string[],
        bottom_right: [] as string[],
        available: [
          "html_block_1",
          "html_block_2",
          "html_block_3",
          "html_block_4",
          "html_block_5",
        ] as string[],
      };

      setLayoutItems(defaultLayout);
    }
  }, [headerSettings.layout]);

  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (!event.data || typeof event.data !== "object") return;

      switch (event.data.type) {
        case "UPDATE_LAYOUT_ITEMS":
          try {
            console.log("Received UPDATE_LAYOUT_ITEMS:", event.data);
            const { source, destination, itemId } = event.data;

            // Clone the current layout items to avoid direct state mutation
            const newLayoutItems = { ...layoutItems };

            // Remove the item from its source container
            if (
              source &&
              source.containerId &&
              Array.isArray(
                newLayoutItems[source.containerId as keyof HeaderLayout]
              )
            ) {
              const sourceArray = newLayoutItems[
                source.containerId as keyof HeaderLayout
              ] as string[];
              const sourceIndex =
                source.index !== undefined
                  ? source.index
                  : sourceArray.indexOf(itemId);

              if (sourceIndex !== -1) {
                sourceArray.splice(sourceIndex, 1);
              }
            }

            // Add the item to its destination container
            if (
              destination &&
              destination.containerId &&
              Array.isArray(
                newLayoutItems[destination.containerId as keyof HeaderLayout]
              )
            ) {
              const destArray = newLayoutItems[
                destination.containerId as keyof HeaderLayout
              ] as string[];
              const destIndex =
                destination.index !== undefined
                  ? destination.index
                  : destArray.length;

              // Splice the item into the destination at the specified index
              destArray.splice(destIndex, 0, itemId);
            }

            // Update the layout items
            debouncedSetLayoutItems(newLayoutItems);

            // Notify parent of the updated layout
            window.parent.postMessage(
              {
                type: "LAYOUT_ITEMS_UPDATED",
                layoutItems: newLayoutItems,
              },
              "*"
            );
          } catch (error) {
            console.error("Error in UPDATE_LAYOUT_ITEMS:", error);
          }
          break;

        case "UPDATE_HEADER_SETTINGS":
          // Update settings immediately without triggering notifications
          setHeaderSettings((prev) => ({ ...prev, ...event.data.settings }));

          // If color schemes were part of the update, notify explicitly
          if (
            event.data.settings.topBarColorScheme !== undefined ||
            event.data.settings.mainBarColorScheme !== undefined ||
            event.data.settings.bottomBarColorScheme !== undefined
          ) {
            // Wait for the state update to complete before notifying
            setTimeout(() => {
              notifySchemeChanges({
                topBarColorScheme: event.data.settings.topBarColorScheme,
                mainBarColorScheme: event.data.settings.mainBarColorScheme,
                bottomBarColorScheme: event.data.settings.bottomBarColorScheme,
              });
            }, 50);
          }

          // Extract HTML block updates
          const htmlUpdates: Record<string, string> = {};
          let hasHtmlUpdates = false;

          for (const key in event.data.settings) {
            if (
              key &&
              typeof key === "string" &&
              key.startsWith("html_block_")
            ) {
              htmlUpdates[key] = event.data.settings[key];
              hasHtmlUpdates = true;
            }
          }

          if (hasHtmlUpdates) {
            console.log("Updating HTML blocks:", htmlUpdates);
            setCustomHtml((prev) => ({
              ...prev,
              ...htmlUpdates,
            }));
          }
          break;

        case "HEADER_GET_STATE":
          console.log("Received HEADER_GET_STATE request");
          window.parent.postMessage(
            {
              type: "HEADER_STATE",
              settings: headerSettings,
              layoutItems,
              schemes: {
                topBarColorScheme: headerSettings.topBarColorScheme || "light",
                mainBarColorScheme:
                  headerSettings.mainBarColorScheme || "light",
                bottomBarColorScheme:
                  headerSettings.bottomBarColorScheme || "light",
              },
            },
            "*"
          );

          // Update the last notified schemes ref to match what we just sent
          lastNotifiedSchemesRef.current = {
            topBarColorScheme: headerSettings.topBarColorScheme || "light",
            mainBarColorScheme: headerSettings.mainBarColorScheme || "light",
            bottomBarColorScheme:
              headerSettings.bottomBarColorScheme || "light",
          };
          break;

        case "HEADER_UPDATE_ALL":
          // Only update if the settings are different
          if (
            event.data.settings &&
            JSON.stringify(event.data.settings) !==
              JSON.stringify(headerSettings)
          ) {
            console.log("Received HEADER_UPDATE_ALL, updating settings");
            setHeaderSettings(event.data.settings);
          } else {
            console.log(
              "Received HEADER_UPDATE_ALL, but settings are the same"
            );
          }

          // Define a helper to detect if settings need to be updated
          // When a property is nested more than 2 levels deep, the changes might
          // not be detected correctly
          const hasSignificantChanges = (
            oldSettings: HeaderLayout,
            newSettings: any
          ) => {
            if (!newSettings) return false;

            // Check top-level properties
            for (const key in newSettings) {
              const typedKey = key as keyof HeaderLayout;

              // Skip if property doesn't exist in oldSettings
              if (!(typedKey in oldSettings)) continue;

              const oldValue = oldSettings[typedKey];
              const newValue = newSettings[typedKey];

              // Check if values are different
              if (
                typeof oldValue !== typeof newValue ||
                JSON.stringify(oldValue) !== JSON.stringify(newValue)
              ) {
                return true;
              }
            }

            return false;
          };

          // Only update layout if the containers are different
          if (
            event.data.layoutItems &&
            hasSignificantChanges(layoutItems, event.data.layoutItems)
          ) {
            console.log("Updating layout items from HEADER_UPDATE_ALL");
            setLayoutItems(event.data.layoutItems);
          }
          break;

        default:
          // Ignore other message types
          break;
      }
    };

    // Add the event listener (only once)
    console.log("Adding message event listener");
    window.addEventListener("message", handleMessage);

    // Return a cleanup function
    return () => {
      console.log("Removing message event listener");
      window.removeEventListener("message", handleMessage);
    };
  }, [
    layoutItems,
    headerSettings,
    debouncedSetLayoutItems,
    notifySchemeChanges,
  ]);

  // Add console logs to debug current color scheme settings
  useEffect(() => {
    console.log("Current header color scheme settings:", {
      topBarColorScheme: headerSettings.topBarColorScheme,
      mainBarColorScheme: headerSettings.mainBarColorScheme,
      bottomBarColorScheme: headerSettings.bottomBarColorScheme,
    });

    // Also log the current style objects
    console.log("Current style objects:", {
      topBarStyles,
      mainBarStyles,
      bottomBarStyles,
    });
  }, [
    headerSettings.topBarColorScheme,
    headerSettings.mainBarColorScheme,
    headerSettings.bottomBarColorScheme,
    topBarStyles,
    mainBarStyles,
    bottomBarStyles,
  ]);

  // Memoize the renderSection function to prevent unnecessary rerenders
  const renderSection = React.useCallback(
    (
      items: string[],
      sectionName: string = "",
      textStyle?: React.CSSProperties
    ) => {
      // Ensure items is an array
      if (!Array.isArray(items)) {
        console.warn(
          `Items for section ${sectionName} is not an array:`,
          items
        );
        return null;
      }

      // Return memoized array of items to prevent unnecessary rerenders
      return items.map((itemId, index) => {
        // Skip if itemId is not a string
        if (typeof itemId !== "string") {
          console.warn(`Invalid item ID in section ${sectionName}:`, itemId);
          return null;
        }

        // For HTML blocks, ensure we're using the exact ID to prevent mismatches
        let renderId = itemId;
        const htmlBlockMatch = itemId.match(/^html_block_(\d+)$/);
        if (htmlBlockMatch && htmlBlockMatch[1]) {
          const blockNumber = htmlBlockMatch[1];
          renderId = `html_block_${blockNumber}`;
        }

        const htmlContent = getHtmlContent(renderId);

        const key = `${sectionName}_${renderId}_${index}`;

        // Don't use useMemo here as it violates the Rules of Hooks
        return (
          <div
            key={key}
            className="header-item"
            data-item-id={renderId}
            data-original-id={itemId}
            dangerouslySetInnerHTML={{ __html: htmlContent }}
            onClick={() => {
              if (isEditing) {
                window.parent.postMessage(
                  { type: "SELECT_HEADER_SETTING", settingId: renderId },
                  "*"
                );
              }
            }}
            style={textStyle}
          />
        );
      });
    },
    [getHtmlContent, isEditing]
  );

  // Function to get direct color values for a scheme
  const getDirectColorValues = useCallback(
    (schemeId: string | undefined, section: string) => {
      if (!schemeId) {
        console.log(
          `No scheme ID provided for ${section} section, using default`
        );
        return {
          background:
            section === "top"
              ? "#f7fafc"
              : section === "main"
              ? "#ffffff"
              : "#f9fafb",
          text:
            section === "top"
              ? "#4a5568"
              : section === "main"
              ? "#1a202c"
              : "#4a5568",
          border: section === "bottom" ? "#e2e8f0" : undefined,
        };
      }

      if (schemeId === "light") {
        return {
          background:
            section === "top"
              ? "#f7fafc"
              : section === "main"
              ? "#ffffff"
              : "#f9fafb",
          text:
            section === "top"
              ? "#4a5568"
              : section === "main"
              ? "#1a202c"
              : "#4a5568",
          border: section === "bottom" ? "#e2e8f0" : undefined,
        };
      }

      if (schemeId === "dark") {
        return {
          background:
            section === "top"
              ? "#2d3748"
              : section === "main"
              ? "#1a202c"
              : "#2d3748",
          text:
            section === "top"
              ? "#e2e8f0"
              : section === "main"
              ? "#f7fafc"
              : "#e2e8f0",
          border: section === "bottom" ? "#4a5568" : undefined,
        };
      }

      // For custom schemes, try to fetch from cache or use default
      return {
        isCustom: true,
        schemeId,
      };
    },
    []
  );

  // Updated header content with direct style application
  const headerContent = React.useMemo(() => {
    // Get color values for each section
    const topColors = getDirectColorValues(
      headerSettings.topBarColorScheme,
      "top"
    );
    const mainColors = getDirectColorValues(
      headerSettings.mainBarColorScheme,
      "main"
    );
    const bottomColors = getDirectColorValues(
      headerSettings.bottomBarColorScheme,
      "bottom"
    );

    // Create direct style objects
    const topStyle: React.CSSProperties = isCustomColorScheme(
      headerSettings.topBarColorScheme
    )
      ? topBarStyles.background
      : { backgroundColor: topColors.background, color: topColors.text };

    const mainStyle: React.CSSProperties = isCustomColorScheme(
      headerSettings.mainBarColorScheme
    )
      ? mainBarStyles.background
      : { backgroundColor: mainColors.background, color: mainColors.text };

    const bottomStyle: React.CSSProperties = isCustomColorScheme(
      headerSettings.bottomBarColorScheme
    )
      ? bottomBarStyles.background
      : {
          backgroundColor: bottomColors.background,
          color: bottomColors.text,
          borderTopColor: bottomColors.border,
          borderTopWidth: "1px",
          borderTopStyle: "solid",
        };

    // Log all styles being applied
    console.log("Applying styles:", {
      top: {
        schemeId: headerSettings.topBarColorScheme,
        style: topStyle,
      },
      main: {
        schemeId: headerSettings.mainBarColorScheme,
        style: mainStyle,
      },
      bottom: {
        schemeId: headerSettings.bottomBarColorScheme,
        style: bottomStyle,
      },
    });

    return (
      <header
        className={`relative shadow ${isEditing ? "editing" : ""} ${
          isSelected ? "selected" : ""
        }`}
        onClick={() => {
          if (isEditing && onSelect) {
            onSelect();
          }
          window.postMessage({ type: "HEADER_SETTING_SELECTED" }, "*");
        }}
        data-top-scheme={headerSettings.topBarColorScheme || "light"}
        data-main-scheme={headerSettings.mainBarColorScheme || "light"}
        data-bottom-scheme={headerSettings.bottomBarColorScheme || "light"}
      >
        {/* Top Bar with direct style application */}
        <div
          className="w-full transition-all grid grid-cols-[auto_1fr_auto] justify-between items-center px-8 gap-4 py-2"
          style={topStyle}
        >
          <div className="flex items-center gap-4 justify-self-start flex-shrink-0">
            {renderSection(
              layoutItems.top_left,
              "top_left",
              isCustomColorScheme(headerSettings.topBarColorScheme)
                ? topBarStyles.text
                : { color: topColors.text }
            )}
          </div>
          <div className="flex gap-6 justify-self-center">
            {renderSection(
              layoutItems.top_center,
              "top_center",
              isCustomColorScheme(headerSettings.topBarColorScheme)
                ? topBarStyles.text
                : { color: topColors.text }
            )}
          </div>
          <div className="flex items-center gap-4 justify-self-end flex-shrink-0">
            {renderSection(
              layoutItems.top_right,
              "top_right",
              isCustomColorScheme(headerSettings.topBarColorScheme)
                ? topBarStyles.text
                : { color: topColors.text }
            )}
            {headerSettings.showTopBarButton && (
              <button className="px-4 py-1 bg-primary text-white rounded-md text-sm hover:bg-primary-dark transition-colors">
                Shop Now
              </button>
            )}
          </div>
        </div>

        {/* Main Section with direct style application */}
        <div
          className="middle-section w-full transition-all grid grid-cols-[auto_1fr_auto] items-center px-8 gap-4 py-4"
          style={mainStyle}
        >
          <div className="flex items-center gap-4 flex-shrink-0">
            {renderSection(
              layoutItems.middle_left,
              "middle_left",
              isCustomColorScheme(headerSettings.mainBarColorScheme)
                ? mainBarStyles.text
                : { color: mainColors.text }
            )}
          </div>
          <div className="flex gap-6 justify-self-center">
            {renderSection(
              layoutItems.middle_center,
              "middle_center",
              isCustomColorScheme(headerSettings.mainBarColorScheme)
                ? mainBarStyles.text
                : { color: mainColors.text }
            )}
          </div>
          <div className="flex items-center gap-4 justify-self-end flex-shrink-0">
            {renderSection(
              layoutItems.middle_right,
              "middle_right",
              isCustomColorScheme(headerSettings.mainBarColorScheme)
                ? mainBarStyles.text
                : { color: mainColors.text }
            )}
          </div>
        </div>

        {/* Bottom Section with direct style application */}
        <div
          className="bottom-section w-full transition-all grid grid-cols-[auto_1fr_auto] items-center px-8 gap-4 py-3"
          style={bottomStyle}
        >
          <div className="flex items-center gap-4 flex-shrink-0">
            {renderSection(
              layoutItems.bottom_left,
              "bottom_left",
              isCustomColorScheme(headerSettings.bottomBarColorScheme)
                ? bottomBarStyles.text
                : { color: bottomColors.text }
            )}
          </div>
          <div className="flex gap-6 justify-self-center">
            {renderSection(
              layoutItems.bottom_center,
              "bottom_center",
              isCustomColorScheme(headerSettings.bottomBarColorScheme)
                ? bottomBarStyles.text
                : { color: bottomColors.text }
            )}
          </div>
          <div className="flex items-center gap-4 justify-self-end flex-shrink-0">
            {renderSection(
              layoutItems.bottom_right,
              "bottom_right",
              isCustomColorScheme(headerSettings.bottomBarColorScheme)
                ? bottomBarStyles.text
                : { color: bottomColors.text }
            )}
          </div>
        </div>
      </header>
    );
  }, [
    isEditing,
    isSelected,
    onSelect,
    headerSettings.showTopBarButton,
    headerSettings.topBarColorScheme,
    headerSettings.mainBarColorScheme,
    headerSettings.bottomBarColorScheme,
    renderSection,
    layoutItems.top_left,
    layoutItems.top_center,
    layoutItems.top_right,
    layoutItems.middle_left,
    layoutItems.middle_center,
    layoutItems.middle_right,
    layoutItems.bottom_left,
    layoutItems.bottom_center,
    layoutItems.bottom_right,
    topBarStyles,
    mainBarStyles,
    bottomBarStyles,
    getDirectColorValues,
  ]);

  // Add a special handler for direct scheme updates
  useEffect(() => {
    // Force a refresh of the iframe when schemes change
    const refreshIframe = () => {
      try {
        const iframe = document.querySelector("iframe");
        if (iframe && iframe.contentDocument) {
          console.log("Forcing style refresh in iframe");
          // Force a repaint by adding and removing a class
          iframe.contentDocument.body.classList.add("refresh-styles");
          setTimeout(() => {
            if (iframe.contentDocument) {
              iframe.contentDocument.body.classList.remove("refresh-styles");
            }
          }, 10);
        }
      } catch (e) {
        console.warn("Could not refresh iframe:", e);
      }
    };

    // Send a special message to force a style update
    if (window.parent) {
      console.log("Sending FORCE_STYLE_UPDATE to parent");
      window.parent.postMessage(
        {
          type: "FORCE_STYLE_UPDATE",
          sections: {
            top: headerSettings.topBarColorScheme,
            main: headerSettings.mainBarColorScheme,
            bottom: headerSettings.bottomBarColorScheme,
          },
        },
        "*"
      );

      // Try to refresh the iframe
      refreshIframe();
    }
  }, [
    headerSettings.topBarColorScheme,
    headerSettings.mainBarColorScheme,
    headerSettings.bottomBarColorScheme,
  ]);

  // Memozied function to get HTML content for a layout item
  const getHtmlContent = React.useCallback(
    (itemId: string): string => {
      // Special handling for logo
      if (itemId === "logo") {
        // Check if we have a logo setting
        if (headerSettings.logo) {
          const logoSettings = headerSettings.logo as {
            text?: string;
            showText?: boolean;
          };
          const logoText = logoSettings.text || "Your Brand";
          const showText = logoSettings.showText !== false;

          // Create logo HTML based on settings
          if (showText) {
            return `<div class="logo-container">
            <img src="/logo.svg" class="h-8" alt="Logo" />
            <span class="ml-2 font-bold text-lg">${logoText}</span>
          </div>`;
          } else {
            return `<img src="/logo.svg" class="h-8" alt="Logo" />`;
          }
        }

        // Fallback to default logo HTML
        return (
          HTMLContentMap.logo ||
          '<img src="/logo.svg" class="h-8" alt="Logo" />'
        );
      }

      // First check customHtml for exact match
      if (customHtml[itemId]) {
        return customHtml[itemId];
      }
      // Then check for HTML blocks in headerSettings
      else if (itemId.startsWith("html_block_")) {
        // Extract the block number
        const blockMatch = itemId.match(/^html_block_(\d+)$/);
        if (blockMatch && blockMatch[1]) {
          const blockNumber = blockMatch[1];
          const settingKey = `html_block_${blockNumber}`;

          // First check customHtml
          if (customHtml[settingKey]) {
            return customHtml[settingKey];
          }
          // Then check headerSettings
          else if (headerSettings[settingKey as keyof HeaderSettings]) {
            return headerSettings[settingKey as keyof HeaderSettings] as string;
          }
          // Finally use HTMLContentMap
          else if (HTMLContentMap[settingKey]) {
            return HTMLContentMap[settingKey];
          }
        }
      }
      // Check if the item is a direct property of headerSettings
      else if (headerSettings[itemId as keyof HeaderSettings]) {
        const settingContent = headerSettings[itemId as keyof HeaderSettings];
        if (typeof settingContent === "string") {
          return settingContent;
        }
      }
      // Finally try HTMLContentMap
      else if (HTMLContentMap[itemId]) {
        return HTMLContentMap[itemId];
      }

      return `<div>${itemId}</div>`;
    },
    [headerSettings, customHtml]
  );

  // Get top bar classes based on settings
  const getTopBarClasses = React.useCallback(() => {
    const classes = [
      "w-full",
      "transition-all",
      "grid grid-cols-[auto_1fr_auto] justify-between items-center px-8 gap-4",
    ];

    // Add color scheme classes
    if (headerSettings.topBarColorScheme) {
      // Try to get color scheme styles
      try {
        const schemeId = headerSettings.topBarColorScheme;
        // Default fallback styling
        if (schemeId === "light" || !schemeId) {
          classes.push("bg-gray-100 text-gray-600");
        } else if (schemeId === "dark") {
          classes.push("bg-gray-800 text-gray-200");
        } else {
          // For custom schemes, we'll apply the styles inline in the component
          // Just add a class to identify it has a custom scheme
          classes.push("custom-color-scheme");
        }
      } catch (error) {
        console.error("Error applying color scheme to top bar:", error);
        // Fallback to light theme
        classes.push("bg-gray-100 text-gray-600");
      }
    } else {
      // Default to light theme if no scheme specified
      classes.push("bg-gray-100 text-gray-600");
    }

    switch (headerSettings.topBarNavStyle) {
      case "style1":
        classes.push("border-b border-gray-200");
        break;
      case "style2":
        classes.push("shadow-sm");
        break;
      case "style3":
        classes.push("border-b-2 border-primary");
        break;
    }

    if (headerSettings.topBarTextTransform) {
      classes.push(headerSettings.topBarTextTransform);
    }

    return clsx(classes);
  }, [
    headerSettings.topBarColorScheme,
    headerSettings.topBarNavStyle,
    headerSettings.topBarTextTransform,
  ]);

  // Add getMainBarClasses and getBottomBarClasses functions similar to getTopBarClasses
  const getMainBarClasses = React.useCallback(() => {
    const classes = [
      "middle-section",
      "w-full",
      "transition-all",
      "grid",
      "grid-cols-[auto_1fr_auto]",
      "items-center",
      "px-8",
      "gap-4",
      "py-4",
    ];

    // Add color scheme classes
    if (headerSettings.mainBarColorScheme) {
      try {
        const schemeId = headerSettings.mainBarColorScheme;
        // Default fallback styling
        if (schemeId === "light" || !schemeId) {
          classes.push("bg-white text-gray-800");
        } else if (schemeId === "dark") {
          classes.push("bg-gray-900 text-gray-100");
        } else {
          // For custom schemes, we'll apply the styles inline in the component
          classes.push("custom-color-scheme");
        }
      } catch (error) {
        console.error("Error applying color scheme to main bar:", error);
        classes.push("bg-white text-gray-800");
      }
    } else {
      classes.push("bg-white text-gray-800");
    }

    return clsx(classes);
  }, [headerSettings.mainBarColorScheme]);

  // Get bottom bar classes with more distinct styling
  const getBottomBarClasses = React.useCallback(() => {
    const classes = [
      "bottom-section",
      "w-full",
      "transition-all",
      "grid",
      "grid-cols-[auto_1fr_auto]",
      "items-center",
      "px-8",
      "gap-4",
      "py-3", // Slightly increased padding
      "border-t", // Add a top border to make it more distinct
    ];

    // Add color scheme classes
    if (headerSettings.bottomBarColorScheme) {
      try {
        const schemeId = headerSettings.bottomBarColorScheme;
        // Default fallback styling with more distinct colors
        if (schemeId === "light" || !schemeId) {
          classes.push("bg-gray-50 text-gray-700 border-gray-200");
        } else if (schemeId === "dark") {
          classes.push("bg-gray-800 text-gray-200 border-gray-700");
        } else {
          // For custom schemes, we'll apply the styles inline in the component
          classes.push("custom-color-scheme");
        }
      } catch (error) {
        console.error("Error applying color scheme to bottom bar:", error);
        classes.push("bg-gray-50 text-gray-700 border-gray-200");
      }
    } else {
      classes.push("bg-gray-50 text-gray-700 border-gray-200");
    }

    return clsx(classes);
  }, [headerSettings.bottomBarColorScheme]);

  return headerContent;
}
